{
  "code": "export default class Utility {\r\n    static calcDistance(a, b) {\r\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\r\n    }\r\n    static getDirectionAToB(A, B, normalize = true) {\r\n        let pA = A.transform.position.clone();\r\n        let pB = B.transform.position.clone();\r\n        let dir = new Laya.Vector3(0, 0, 0);\r\n        Laya.Vector3.subtract(pB, pA, dir);\r\n        if (normalize)\r\n            Laya.Vector3.normalize(dir, dir);\r\n        return dir;\r\n    }\r\n    static fixPosY(y, designHeight = 1334) {\r\n        return y * Laya.stage.displayHeight / designHeight;\r\n    }\r\n    static findNodeByName(rootNode, name) {\r\n        let targetNode = null;\r\n        let funC = (node) => {\r\n            for (let i = 0; i < node.numChildren; i++) {\r\n                if (node.getChildAt(i).name == name) {\r\n                    targetNode = node.getChildAt(i);\r\n                    return;\r\n                }\r\n                else {\r\n                    funC(node.getChildAt(i));\r\n                }\r\n            }\r\n        };\r\n        funC(rootNode);\r\n        return targetNode;\r\n    }\r\n    static TmoveTo(node, duration, des, cb, ease) {\r\n        let t = new Laya.Tween();\r\n        var posOld = node.transform.position;\r\n        t.to(node.transform.position, {\r\n            x: des.x,\r\n            y: des.y,\r\n            z: des.z,\r\n            update: new Laya.Handler(this, () => {\r\n                node.transform.position = posOld;\r\n            })\r\n        }, duration, ease ? ease : Laya.Ease.cubicOut, Laya.Handler.create(this, () => {\r\n            cb && cb();\r\n        }));\r\n    }\r\n    static RotateTo(node, duration, des, cb) {\r\n        var rotationOld = node.transform.localRotationEuler;\r\n        Laya.Tween.to(node.transform.localRotationEuler, {\r\n            x: des.x,\r\n            y: des.y,\r\n            z: des.z,\r\n            update: new Laya.Handler(this, function () {\r\n                if (node)\r\n                    node.transform.localRotationEuler = rotationOld;\r\n            })\r\n        }, duration, Laya.Ease.cubicOut, Laya.Handler.create(this, function () {\r\n            cb && cb();\r\n        }));\r\n    }\r\n    static tMove2D(node, x, y, t, cb) {\r\n        Laya.Tween.to(node, { x: x, y: y }, t, null, new Laya.Handler(this, () => {\r\n            if (cb)\r\n                cb();\r\n        }));\r\n    }\r\n    static updateNumber(baseNum, times, label, labelOrFont = true, inclease, cb) {\r\n        let timesNum = baseNum * times;\r\n        let dt = Math.floor((timesNum - baseNum) / 60);\r\n        dt = dt <= 0 ? 1 : dt;\r\n        let func = () => {\r\n            if (inclease) {\r\n                baseNum += dt;\r\n                if (baseNum >= timesNum) {\r\n                    baseNum = timesNum;\r\n                    cb && cb();\r\n                    Laya.timer.clear(this, func);\r\n                }\r\n                if (labelOrFont)\r\n                    label.text = baseNum.toString();\r\n                else\r\n                    label.value = baseNum.toString();\r\n            }\r\n            else {\r\n                timesNum -= dt;\r\n                if (timesNum <= baseNum) {\r\n                    timesNum = baseNum;\r\n                    cb && cb();\r\n                    Laya.timer.clear(this, func);\r\n                }\r\n                if (labelOrFont)\r\n                    label.text = timesNum.toString();\r\n                else\r\n                    label.value = timesNum.toString();\r\n            }\r\n        };\r\n        Laya.timer.frameLoop(1, this, func);\r\n    }\r\n    static loadJson(str, complete) {\r\n        Laya.loader.load(str, Laya.Handler.create(this, complete), null, Laya.Loader.JSON);\r\n    }\r\n    static objectShake(target, shakeTime = 1, shakeAmount = 0.7) {\r\n        var shake = shakeTime;\r\n        var decreaseFactor = 1;\r\n        var originalPos = target.transform.localPosition.clone();\r\n        Laya.timer.frameLoop(1, this, updateShake);\r\n        function randomPos() {\r\n            var x = Math.random() > 0.5 ? Math.random() : -(Math.random());\r\n            var y = Math.random() > 0.5 ? Math.random() : -(Math.random());\r\n            return new Laya.Vector3(x, y, 0);\r\n        }\r\n        function updateShake() {\r\n            if (shake > 0) {\r\n                var pos = new Laya.Vector3();\r\n                Laya.Vector3.scale(randomPos(), shakeAmount, pos);\r\n                Laya.Vector3.add(originalPos, pos, pos);\r\n                target.transform.localPosition = pos;\r\n                shake -= 0.02 * decreaseFactor;\r\n            }\r\n            else {\r\n                shake = 0;\r\n                target.transform.localPosition = originalPos;\r\n                Laya.timer.clear(this, updateShake);\r\n            }\r\n        }\r\n    }\r\n    static getRandomItemInArr(arr) {\r\n        return arr[Math.floor(Math.random() * arr.length)];\r\n    }\r\n}\r\n",
  "references": []
}
